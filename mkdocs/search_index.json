{
    "docs": [
        {
            "location": "/", 
            "text": "Tutorial\n\n\nAbout\n\n\nThis is a tutorial on how to write a node that sets up features in your Maya\nscene without having explicit dirty propagation relationships in the dependency graph.\n\n\nFor this node, we're going to focus mostly on the \nhow\n of writing the node\nitself, and thus the actual functionality will be restricted to something very\nbasic; in this case, creating a spiral motion when a user moves the transform\nnode in the scene that we set up the feature for.\n\n\nFor more information on this approach to setting up scene features, please refer\nto \nRaffaele Fragapane's\n \nCult Of Rig\n series on the\nreasoning behind this approach. \n\n\nWhy not just do what Raffaele does and use a \nscriptNode\n?\n\n\nThe reason we're using a compiled node here instead of a \nscriptNode\n as he\ndetails in the original approach is due to the fact that the script executed\nfrom a script node in Maya has no concept of which node executed it, and thus\nmakes it very difficult to implement in production when you reference this\nscript node in a separate namespace without implementing a callback manager of\nsome sort to manage the callbacks you are installing into the scene, along with\nmanaging the associated namespaces/nodes for each of those callbacks registered\nby the script node.\n\n\nBy using a compiled node instead, we can manage all of that registration/\nun-registration mess within the node itself much more cleanly and reason about\nthe state of our Maya scene a lot more easily than a script node would otherwise\nhave allowed for.\n\n\nRequirements\n\n\nWhat you should know\n\n\n\n\nBasic knowledge of C/C++\n. I will focus on including only the code that is\n  important; I expect you to be able to understand how to fill in the rest as needed.\n\n\nKnowledge of how the dependency graph works in Maya and how dirty propagation works.\n\n\nBasic knowledge of how Maya plugins work and how to write/build them\n. There is\n  a sample \nCMakeLists.txt\n build script provided for reference if you need a\n  refresher on that.\n\n\nIf you're unfamilar with Maya's callback mechanisms, to \nwatch the stream\n\n  listed above to get an idea of what's going on and how they tie to dirty\n  propagation in the dependency graph.\n\n\nMost importantly: \nHow to convert between tabs/spaces.\n (Of course, you\n  should also prefer tabs, but this is a well-understood \nfact\n, and so I don't\n  think further discussion is required on the topic.)\n\n\n\n\nGetting started\n\n\nFirstly, we'll just get a basic skeleton setup of the plugin going. As a refresher,\nthis just means that you need to create a defintion of a \nMPxNode\n\nthat implements a creator function and an initializer function, which\nwe will call \ncreator()\n and \ninitialize()\n respectively.\n\n\nThus, in \ncallback_node.h\n:\n\n\n/// This is a dependency node that will install a callback during its lifetime.\nclass CallbackNode : MPxNode\n{\npublic:\n    static void *creator();\n\n    static MStatus initialize();\n\n    static const MTypeId kNODE_ID;      /// The unique ID that identifies this node.\n    static const MString kNODE_NAME;    /// The name of the DG node.\n\n\n\n\nAnd \ncallback_node.cpp\n, which, for now, looks pretty sparse:\n\n\n#include \ncallback_node.h\n\n\nconst MTypeId CallbackNode::kNODE_ID(0x0007ffff);\nconst MString CallbackNode::kNODE_NAME = \ncallbackNodeExample\n;\n\n\nvoid *CallbackNode::creator()\n{\n    return new CallbackNode();\n}\n\n\nMStatus CallbackNode::initialize()\n{\n    MStatus result;\n    return result;\n}\n\n\n\n\nWe also add two extra attributes called \nkNODE_ID\n and \nkNODE_NAME\n to help\nus identify the dependency node later on.\n\n\nGreat! We've got our node now, let's write the basic plugin structure to\nregister it. In case you needed a refresher:\n\n\nIn \nplugin_main.cpp\n:\n\n\n#include \nplugin_main.h\n\n#include \nmaya/MFnPlugin.h\n\n\nconst char *kAUTHOR = \nMe, the author\n;\nconst char *kVERSION = \n1.0.0\n;\nconst char *kREQUIRED_API_VERSION = \nAny\n;\n\n\nMStatus initializePlugin(MObject obj)\n{\n    MStatus status;\n    MFnPlugin plugin(obj, kAUTHOR, kVERSION, kREQUIRED_API_VERSION);\n\n    status = plugin.registerNode(CallbackNode::kNODE_NAME,\n                                 CallbackNode::kNODE_ID,\n                                 \nCallbackNode::creator,\n                                 \nCallbackNode::initialize,\n                                 MPxNode::kDependNode);\n    CHECK_MSTATUS_AND_RETURN_IT(status);\n\n    return status;\n}\n\n\nMStatus uninitializePlugin(MObject obj)\n{\n    MFnPlugin plugin(obj);\n\n    MStatus status;\n    status =  plugin.deregisterNode(CallbackNode::kNODE_ID);\n    CHECK_MSTATUS_AND_RETURN_IT(status);\n\n    return status;\n}\n\n\n\n\nIn \nplugin_main.h\n, I go ahead and setup a \nSingle Translation Unit (STU)\nBuild/Unity build\n (which is easy, since there's only one\nsource file right now): \n\n\n#include \ncallback_node.cpp\n\n\nMStatus initializePlugin(MObject obj);\n\nMStatus uninitializePlugin(MObject obj);\n\n\n\n\nYou should be able to call the compiler command on your corresponding platform\non just \nplugin_main.cpp\n and have the plugin compile correctly.\n\n\nI will not go into the details regarding a STU build here, but suffice to say\nthat I have found them much more beneficial to build times than any other\ncompiler feature (LTO, IncrediBuild, splitting the code out into pre-compiled\nlibs, whatever). For such a small project, it doesn't matter; you can switch back\nto a more traditional build setup if you prefer.\n\n\nIf you have issues building the plugin on your own, please refer to the\nincluded \nCMakeLists.txt\n to see how I manage my own builds. You are not\nrequired to use CMake; it is just my own preference.\n\n\nIf you got past all that and got a plugin building, great! We have a node that\ndoes...well, \nnothing\n.\n\n\nNow we just need to make it work.\n\n\nWhat are we even doing?\n\n\nSo before we jump into the node's features itself, let's take a step back and\nthink about what we want this node to do at a high-level:\n\n\n\n\n\n\n\n\n\n\n\n\n\n\ncallbackNodeExample\n\n\n\n\n\n\ntransform\n\n\n\n\nTransform node\n\n\n\n\n\n\ncallback\n\n\n\n\nCallback node\n\n\n\n\n\n\ntransform\ncallback\n\n\n\n\n\n\n \n1. Read translateX\n\n\n\n\n\n\ncallback\ntransform\n\n\n\n\n\n\n \n2. Set new translate Y/Z in a spiral\nly fashion\n\n\n\n\n\n\n\n\n\nOk. So we know that we want to our node read the translate information from the \ntransform node. However, I just promised that we wouldn't have explicit\nconnections between our nodes in the DG. So what we'll do instead is use\n\nmessage attributes\n to do the job of making sure our nodes know about each\nother. Kind of like Tinder, but just for DG nodes.\n\n\nCreating the message attribute\n\n\nIf you need a refresher on what a message attribute is:\n\n\n\n\nA message attribute is a dependency node attribute that does not transmit\ndata\n. \nMessage attributes only exist to formally declare relationships between\nnodes. By connecting two nodes via message attributes, a relationship between\nthose nodes is expressed.\n\n\nThe Maya Documentation for \nMFnMessageAttribute\n, verse 2:0\n\n\n\n\nBasically, by utilizing this Maya feature, we'll be able to avoid having any data\ntransmitted explicitly in the graph; we'll be reading it directly from the\ntransform node itself.\n\n\nLet's add this message attribute to our custom node definition:\n\n\nconst char *CallbackNode::kIN_TRANSFORM_ATTR_NAME = \ntransform\n;\nMObject CallbackNode::inTransformAttr;\n\n\nMStatus CallbackNode::initialize()\n{\n    MStatus result;\n\n    MFnMessageAttribute fnMsgAttr;\n    inTransformAttr = fnMsgAttr.create(CallbackNode::kIN_TRANSFORM_ATTR_NAME,\n                                       CallbackNode::kIN_TRANSFORM_ATTR_NAME,\n                                       \nresult);\n    CHECK_MSTATUS_AND_RETURN_IT(result);\n\n    addAttribute(inTransformAttr);\n    return result;\n}\n\n\n\n\nHowever, let's not forget that this attribute needs to be connected to\nsomething. In this case, that something is the transform node that we're going\nto be moving around. \n\n\nWriting the \nMPxCommand\n to setup everything\n\n\nTo make things easier for our end-users, let's make a \nMPxCommand\n that they \ncan run in order to create our node automatically, along with handling the connections \nbetween it and the transform node. If you've never written such a thing before\nor need some reference, the command I've written is below:\n\n\napply_callback_command.h\n\n\nclass ApplyCallbackCommand : public MPxCommand\n{\npublic:\n    static void *creator();\n\n    MStatus doIt(const MArgList \nargs);\n\n    MStatus redoIt();\n\n    MStatus undoIt();\n\n    bool isUndoable() const;\n\n    static MSyntax newSyntax();\n\n    /// The name of the command that is meant to be run.\n    static const MString kCOMMAND_NAME;\n\n    MStatus parseArgs(const MArgList \nargs);\n\n    /// Storage for the flag arguments that will be passed into the command.\n    bool flagHelpSpecified = false;\n    MSelectionList flagSelList;\n\n    /// Storage for the operations that this command performs on the DG so that we\n    /// can undo them if necessary.\n    MDGModifier dgMod;\n};\n\n\n\n\nAnd \napply_callback_command.cpp\n:\n\n\n\nconst char *flagSelListLongName = \n-node\n;\nconst char *flagSelListShortName = \n-n\n;\n\nconst char *flagHelpLongName = \n-help\n;\nconst char *flagHelpShortName = \n-h\n;\n\nconst char *helpText = \nThis command will setup a callback on a given node.\\n\n\n    \nUsage:\\n   applyCallback [options]\\n\n\n    \nOptions:\\n\n\n    \n-h / -help     Prints this message.\\n\\n\n\n    \n-n / -node     The name of the node to setup the callback example for.\\n\\n\n;\n\nconst MString ApplyCallbackCommand::kCOMMAND_NAME = \napplyCallback\n;\n\n\nvoid *ApplyCallbackCommand::creator()\n{\n    return new ApplyCallbackCommand();\n}\n\n\nMSyntax ApplyCallbackCommand::newSyntax()\n{\n    MSyntax syntax;\n    syntax.addFlag(flagHelpShortName, flagHelpLongName);\n    syntax.addFlag(flagSelListShortName, flagSelListLongName, MSyntax::kSelectionItem);\n    syntax.enableQuery(false);\n    syntax.enableEdit(false);\n    syntax.useSelectionAsDefault(true);\n\n    return syntax;\n}\n\n\nMStatus ApplyCallbackCommand::parseArgs(const MArgList \nargs)\n{\n    MStatus result;\n    MArgDatabase argDb(syntax(), args, \nresult);\n    CHECK_MSTATUS_AND_RETURN_IT(result);\n\n    if (argDb.isFlagSet(flagHelpShortName)) {\n        displayInfo(helpText);\n        flagHelpSpecified = true;\n        return MStatus::kSuccess;\n    } else {\n        flagHelpSpecified = false;\n    }\n\n    if (argDb.isFlagSet(flagSelListShortName)) {\n        argDb.getFlagArgument(flagSelListShortName, 0, flagSelList);\n    }\n\n    return result;\n}\n\n\nMStatus ApplyCallbackCommand::doIt(const MArgList \nargs)\n{\n    setCommandString(ApplyCallbackCommand::kCOMMAND_NAME);\n    clearResult();\n\n    MStatus result = parseArgs(args);\n    CHECK_MSTATUS_AND_RETURN_IT(result);\n\n    if (this-\nflagHelpSpecified == true) {\n        return MStatus::kSuccess;\n    }\n\n    return redoIt();\n}\n\n\nMStatus ApplyCallbackCommand::redoIt()\n{\n    MStatus result;\n    if (flagSelList.length() != 1) {\n        MGlobal::displayError(\nYou need to select a single node to apply the callback to!\n);\n        return MStatus::kInvalidParameter;\n    }\n\n    if (doesCallbackNodeAlreadyExist() == true) {\n        MGlobal::displayError(\nThe feature already exists!\n);\n        return MStatus::kFailure;\n    }\n\n    MObject callbackNode = dgMod.createNode(CallbackNode::kNODE_ID, \nresult);\n    CHECK_MSTATUS_AND_RETURN_IT(result);\n    result = dgMod.doIt();\n    CHECK_MSTATUS_AND_RETURN_IT(result);\n\n    MFnDependencyNode fnNode(callbackNode);\n    MPlug callbackNodeMsgPlug = fnNode.findPlug(CallbackNode::kIN_TRANSFORM_ATTR_NAME,\n                                                false,\n                                                \nresult);\n    CHECK_MSTATUS_AND_RETURN_IT(result);\n\n    MObject transform;\n    result = flagSelList.getDependNode(0, transform);\n    CHECK_MSTATUS_AND_RETURN_IT(result);\n    if (!transform.hasFn(MFn::kDependencyNode)) {\n        MGlobal::displayError(\nThe object specified is not a valid DG node!\n);\n        return MStatus::kInvalidParameter;\n    }\n\n    return result;\n}\n\n\nMStatus ApplyCallbackCommand::undoIt()\n{\n    dgMod.undoIt();\n    return MStatus::kSuccess;\n}\n\n\nbool ApplyCallbackCommand::isUndoable() const\n{\n    if (flagHelpSpecified == true) {\n        return false;\n    } else {\n        return true;\n    }\n}\n\n\n\n\nIt's a bit of boilerplate code to write, but it's not that complicated when you\nsee what it's actually doing. We basically create a new \nCallbackNode\n, \naccept a single transform as a command argument, and do some basic sanity\nchecking of the inputs to make sure everything's good. Nothing special, really. \n\n\n(Again, if something here doesn't make sense to you, please look through some of\nthe examples of how to write command plugins in the Maya documentation.)\n\n\nThere's one thing we need to do before we call this command good, though; we\nneed to actually make the connection between the callback node and the transform\nnode that we pass to the command:\n\n\n    //... the earlier part of redoIt()\n    MObject transform;\n    result = flagSelList.getDependNode(0, transform);\n    CHECK_MSTATUS_AND_RETURN_IT(result);\n    if (!transform.hasFn(MFn::kDependencyNode)) {\n        MGlobal::displayError(\nThe object specified is not a valid DG node!\n);\n        return MStatus::kInvalidParameter;\n    }\n    result = fnNode.setObject(transform);\n    CHECK_MSTATUS_AND_RETURN_IT(result);\n    if (!fnNode.hasAttribute(CallbackNode::kMSG_CXN_ATTR_NAME)) {\n        MFnMessageAttribute fnMsgAttr;\n        MObject msgAttr = fnMsgAttr.create(CallbackNode::kMSG_CXN_ATTR_NAME,\n                                           CallbackNode::kMSG_CXN_ATTR_NAME,\n                                           \nresult);\n        CHECK_MSTATUS_AND_RETURN_IT(result);\n        fnNode.addAttribute(msgAttr);\n    }\n    MDGModifier dgModCxn;\n    MPlug msgPlug = fnNode.findPlug(CallbackNode::kMSG_CXN_ATTR_NAME, false, \nresult);\n    CHECK_MSTATUS_AND_RETURN_IT(result);\n    result = dgModCxn.connect(msgPlug, callbackNodeMsgPlug);\n    CHECK_MSTATUS_AND_RETURN_IT(result);\n    dgModCxn.doIt();\n\n\n\n\nWe basically create a new message attribute on the transform node and connect it\nup (using a different \nMDGModifier\n, since our internal one is going to be\nreserved for deleting the callback node we created if the user chooses to undo,\nand deleting the node will automatically break the connections anyway)\n\n\nWe also need to define \nCallbackNode::kMSG_CXN_ATTR_NAME\n and \n\nCallbackNode::kIN_TRANSFORM_ATTR_NAME\n, which will be the names of the\nmessage attributes on the callback and transform nodes respectively. You can do\nthat in the respective source files however you like.\n\n\nGetting somewhere\n\n\nOnce all of that is done and your plugin is built, you should be able to run the \nfollowing MEL script (or similar):\n\n\nfile -f -newFile;\nunloadPlugin \ncallbackNodeExample\n;\nloadPlugin \nc:/Users/sonictk/Git/experiments/maya_node_callback_example/build/Debug/callbackNodeExample.mll\n;\n\ncreateNode \ntransform\n;\napplyCallback -n \ntransform1\n;\n\n\n\n\nWhich should give you something similar to the following:\n\n\n\n\n\n\n\n\n\n\n\n\n\n\ncallbackNodeExample\n\n\n\n\n\n\ntransform\n\n\n\n\nTransform node\n\n\n\n\ncallback node msg. attr.\n\n\n\n\n\n\ncallback\n\n\n\n\nCallback node\n\n\n\n\ntransform node msg. attr.\n\n\n\n\n\n\ntransform:f1\ncallback:f1\n\n\n\n\n\n\nmessage conn.\n\n\n\n\n\n\n\n\n\nIf you're still following along; great! Let's now focus on actually \ndoing\n\nsomething useful with the nodes we've made.\n\n\nA more detailed overview of the entire setup\n\n\nNow that we've established the relationship between the nodes, let's think about\nwhat we need to do next. We know that we want to get the \ntranslateX\n value\nfrom the transform node whenever a user changes it interactively. We also know\nthat we don't want this behaviour to be dirty propagation-based (i.e. no\nexplicit connection in the graph). \n\n\nIf you paid attention at all during the stream, you'll know what the answer is:\nit's in the form of Maya's various callback mechanisms. However, before we jump\nright into writing it up, let's think a little again over what we need to do in\ngreater detail this time:\n\n\n\n\n\n\n\n\n\n\n\n\n\n\ncallbackNodeExample\n\n\n\n\n\n\ntransform\n\n\n\n\nTransform node\n\n\n\n\ncallback node msg. attr.\n\n\n\n\ntranslateX\n\n\n\n\nattr. changed callback\n\n\n\n\ntranslateY/Z\n\n\n\n\n\n\ntransform:f2\ntransform:f3\n\n\n\n\n\n\n\n\n\n\ncallback\n\n\n\n\nCallback node\n\n\n\n\ntransform node msg. attr.\n\n\n\n\ninstallation callback\n\n\n\n\ncallback registry\n\n\n\n\n\n\ntransform:f1\ncallback:f1\n\n\n\n\n\n\nmessage conn.\n\n\n\n\n\n\ntransform:f3\ncallback:f3\n\n\n\n\n\n\ncallback ID is stored so that \n\n\nit can be un\nregistered on node \n\n\ndeletion/disconnection\n\n\n\n\n\n\nreadTranslateXCB\n\n\n\n\nCallback function\n\n\n\n\n\n\ntransform:f3\nreadTranslateXCB\n\n\n\n\n\n\n2. Calls function when translateX. \n\n\nchanges interactively on transform node\n\n\n\n\n\n\ncallback:f2\ntransform:f3\n\n\n\n\n\n\n1. Registers this callback when \n\n\nnode is created/connected\n\n\n\n\n\n\nreadTranslateXCB\ntransform:f4:s\n\n\n\n\n\n\n3. Sets final ty/tz values \n\n\non the transform node\n\n\n\n\n\n\n\n\n\nOk, that's a little confusing. As\na \ngreat man\n \nonce said, let's \nbreak it down\n.\n\n\nRegistering the callback onto the transform node\n\n\n\n\n\n\n\n\n\n\n\n\n\n\ncallbackNodeExample\n\n\n\n\n\n\ntransform\n\n\n\n\nTransform node\n\n\n\n\ncallback node msg. attr.\n\n\n\n\ntranslateX\n\n\n\n\nattr. changed callback\n\n\n\n\ntranslateY/Z\n\n\n\n\n\n\ntransform:f2\ntransform:f3\n\n\n\n\n\n\n\n\n\n\ncallback\n\n\n\n\nCallback node\n\n\n\n\ntransform node msg. attr.\n\n\n\n\ninstallation callback\n\n\n\n\ncallback registry\n\n\n\n\n\n\ntransform:f1\ncallback:f1\n\n\n\n\n\n\nmessage conn.\n\n\n\n\n\n\ntransform:f3\ncallback:f3\n\n\n\n\n\n\ncallback ID is stored so that \n\n\nit can be un\nregistered on node \n\n\ndeletion/disconnection\n\n\n\n\n\n\nreadTranslateXCB\n\n\n\n\nCallback function\n\n\n\n\n\n\ntransform:f3\nreadTranslateXCB\n\n\n\n\n\n\n2. Calls function when\n\n\n \ntranslateX. \n\n\nchanges interactively on transform node\n\n\n\n\n\n\ncallback:f2\ntransform:f3\n\n\n\n\n\n\n1. Registers this callback when \n\n\nnode is created/connected\n\n\n\n\n\n\nreadTranslateXCB\ntransform:f4:s\n\n\n\n\n\n\n3. Sets final ty/tz values \n\n\non the transform node\n\n\n\n\n\n\n\n\n\nWe already did the message connection earlier, so we can move on.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\ncallbackNodeExample\n\n\n\n\n\n\ntransform\n\n\n\n\nTransform node\n\n\n\n\ncallback node msg. attr.\n\n\n\n\ntranslateX\n\n\n\n\nattr. changed callback\n\n\n\n\ntranslateY/Z\n\n\n\n\n\n\ntransform:f2\ntransform:f3\n\n\n\n\n\n\n\n\n\n\ncallback\n\n\n\n\nCallback node\n\n\n\n\ntransform node msg. attr.\n\n\n\n\ninstallation callback\n\n\n\n\ncallback registry\n\n\n\n\n\n\ntransform:f1\ncallback:f1\n\n\n\n\n\n\nmessage conn.\n\n\n\n\n\n\ntransform:f3\ncallback:f3\n\n\n\n\n\n\ncallback ID is stored so that \n\n\nit can be un\nregistered on node \n\n\ndeletion/disconnection\n\n\n\n\n\n\nreadTranslateXCB\n\n\n\n\nCallback function\n\n\n\n\n\n\ntransform:f3\nreadTranslateXCB\n\n\n\n\n\n\n2. Calls function when\n\n\n \ntranslateX. \n\n\nchanges interactively on transform node\n\n\n\n\n\n\ncallback:f2\ntransform:f3\n\n\n\n\n\n\n1. Registers this callback when \n\n\nnode is created/connected\n\n\n\n\n\n\nreadTranslateXCB\ntransform:f4:s\n\n\n\n\n\n\n3. Sets final ty/tz values \n\n\non the transform node\n\n\n\n\n\n\n\n\n\nLet's start here instead. We need to set-up a callback on the callback node when\nit is created that is responsible for \nsetting up another callback on the\ntransform node\n in order to watch for any attribute changes on it. We can do\nthis by making use of the \nMPxNode::postConstructor\n virtual method, like so:\n\n\n\nvoid CallbackNode::postConstructor()\n{\n    MStatus status;\n    MObject thisNode = thisMObject();\n\n    MCallbackId installId = MNodeMessage::addAttributeChangedCallback(thisNode,\n                                                                      installCallback,\n                                                                      NULL,\n                                                                      \nstatus);\n    if (status != MStatus::kSuccess) {\n        MGlobal::displayError(\nUnable to install example feature!\n);\n        uninstallCallback();\n        return;\n    }\n    callbacks.append(installId);\n    MNodeMessage::addNodePreRemovalCallback(thisNode,\n                                            uninstallCallback,\n                                            NULL,\n                                            \nstatus);\n    if (status != MStatus::kSuccess) {\n        MGlobal::displayError(\nUnable to install example feature!\n);\n        uninstallCallback();\n        return;\n    }\n}\n\n\n\n\n\nWhat are \ninstallCallback\n and \nuninstallCallback\n, you ask? Let's take a\nlook at the documentation for both \nMNodeMessage::addAttributeChangedCallback\n\nand \nMNodeMessage::addNodePreRemovalCallback\n to get some hints:\n\n\nMCallbackId addAttributeChangedCallback(MObject \nnode, \n                                        MNodeMessage::MAttr2PlugFunction func, \n                                        void *clientData = NULL, \n                                        MStatus *ReturnStatus = NULL)\n\nMCallbackId addNodePreRemovalCallback(MObject \nnode, \n                                      MMessage::MNodeFunction func, \n                                      void *clientData = NULL, \n                                      MStatus *ReturnStatus = NULL)\n\n\n\n\nSo basically our \ninstallCallback\n and \nuninstallCallback\n functions need to\nmatch the signatures of a \nMAttr2PlugFunction\n and a \nMNodeFunction\n,\nwhatever those might be. Looking at an \nMAttr2PlugFunction\n signature gives\nthe following:\n\n\n\ntypedef void(* MAttr2PlugFunction) (MNodeMessage::AttributeMessage msg, \n                                    MPlug \nplug, \n                                    MPlug \notherPlug, \n                                    void *clientData)\n\n\n\n\n\nBasically a function pointer that takes two \nMPlugs\n. And a \nMNodeFunction\n?\n\n\n\ntypedef void(* MNodeFunction) (MObject \nnode, void *clientData)\n\n\n\n\n\nYep, a function pointer that takes a \nMObject\n node. Not terribly complicated,\nwhich is always good.\n\n\nKnowing this, we can go ahead and starting writing our callback functions:\n\n\n\nMStatus uninstallCallback()\n{\n    MStatus status = MMessage::removeCallbacks(CallbackNode::callbacks);\n    MGlobal::displayInfo(\nRemoved feature!\n);\n    return status;\n}\n\n\nvoid uninstallCallback(MObject \nnode, void *data)\n{\n    uninstallCallback();\n}\n\n\nvoid installCallback(MNodeMessage::AttributeMessage msg,\n                     MPlug \nplug,\n                     MPlug \notherPlug,\n                     void *data)\n{\n    if (msg == (MNodeMessage::kConnectionBroken|\n                MNodeMessage::kIncomingDirection|\n                MNodeMessage::kOtherPlugSet)) {\n        uninstallCallback();\n    }\n    if (msg != (MNodeMessage::kConnectionMade|\n                MNodeMessage::kIncomingDirection|\n                MNodeMessage::kOtherPlugSet)) {\n        return;\n    }\n    // NOTE: (sonictk) We check if the node has its message connection connected\n    // first to determine if we should install the real callback onto that node\n    MObject callbackNode = plug.node();\n    MFnDependencyNode fnNode(callbackNode);\n    MPlug cxnPlug = fnNode.findPlug(CallbackNode::kIN_TRANSFORM_ATTR_NAME);\n    MPlugArray connectedPlugs;\n    cxnPlug.connectedTo(connectedPlugs, true, false);\n    if (connectedPlugs.length() != 1) {\n        return;\n    }\n    MObject transformNode = connectedPlugs[0].node();\n    if (!transformNode.hasFn(MFn::kTransform)) {\n        return;\n    }\n    // NOTE: (sonictk) Install the callback onto the other node and add it to the\n    // registry of callbacks to track\n    MStatus status;\n    MCallbackId featureCallbackId = MNodeMessage::addAttributeChangedCallback(transformNode,\n                                                                              featureCallback,\n                                                                              NULL,\n                                                                              \nstatus);\n    if (status != MStatus::kSuccess) {\n        return;\n    }\n    CallbackNode::callbacks.append(featureCallbackId);\n    MGlobal::displayInfo(\nFeature installed!\n);\n\n}\n\n\n\n\n\nBasically, we check the message type that Maya passes us to see if we care about\nthe type of event that just occurred, and either remove the callbacks from a\nglobal registry that the node maintains if we detect a disconnection, or install\na new callback onto the transform node otherwise. Yes, this means we also need\nto define what this \"global callback registry\" is:\n\n\nstatic MCallbackIdArray callbacks;\n\n\n\n\nThat's it. No need to over-complicate matters. (Remember, in a STU build, any\nvariable with \nstatic\n storage duration is effectively global!)\n\n\nWe'll implement \nfeatureCallback\n in a little bit. For now, let's look at what\nour overview looks like now:\n\n\n\n\n\n\n\n\n\n\n\n\n\n\ncallbackNodeExample\n\n\n\n\n\n\ntransform\n\n\n\n\nTransform node\n\n\n\n\ncallback node msg. attr.\n\n\n\n\ntranslateX\n\n\n\n\nattr. changed callback\n\n\n\n\ntranslateY/Z\n\n\n\n\n\n\ntransform:f2\ntransform:f3\n\n\n\n\n\n\n\n\n\n\ncallback\n\n\n\n\nCallback node\n\n\n\n\ntransform node msg. attr.\n\n\n\n\ninstallation callback\n\n\n\n\ncallback registry\n\n\n\n\n\n\ntransform:f1\ncallback:f1\n\n\n\n\n\n\nmessage conn.\n\n\n\n\n\n\ntransform:f3\ncallback:f3\n\n\n\n\n\n\ncallback ID is stored so that \n\n\nit can be un\nregistered on node \n\n\ndeletion/disconnection\n\n\n\n\n\n\nreadTranslateXCB\n\n\n\n\nCallback function\n\n\n\n\n\n\ntransform:f3\nreadTranslateXCB\n\n\n\n\n\n\n2. Calls function when\n\n\n \ntranslateX. \n\n\nchanges interactively on transform node\n\n\n\n\n\n\ncallback:f2\ntransform:f3\n\n\n\n\n\n\n1. Done!\n\n\n\n\n\n\nreadTranslateXCB\ntransform:f4:s\n\n\n\n\n\n\n3. Sets final ty/tz values \n\n\non the transform node\n\n\n\n\n\n\n\n\n\nYes, we did skip a little ahead, but it was all for a good cause. Let's go ahead\nand implement that \nfeatureCallback\n now to read the \ntranslateX\n value off\nof the transform node.\n\n\n\nvoid featureCallback(MNodeMessage::AttributeMessage msg,\n                     MPlug \nplug,\n                     MPlug \notherPlug,\n                     void *data)\n{\n    if (msg != (MNodeMessage::kAttributeSet|MNodeMessage::kIncomingDirection)) {\n        return;\n    }\n    const char *plugName = plug.partialName(0,0,0,0,0,1).asChar();\n    if (strstr(\ntranslateX\n, plugName) == NULL) {\n        return;\n    }\n    double xVal = plug.asDouble();\n}\n\n\n\n\nAs we can see, it's very similar in theory to how we implemented\n\ninstallCallback\n; the difference here being that we look for a different type\nof event (\nkAttributeSet\n instead), and we just get the value of the\ntranslateX plug without doing anything else.\n\n\nSo just like that, our overview looks like this:\n\n\n\n\n\n\n\n\n\n\n\n\n\n\ncallbackNodeExample\n\n\n\n\n\n\ntransform\n\n\n\n\nTransform node\n\n\n\n\ncallback node msg. attr.\n\n\n\n\ntranslateX\n\n\n\n\nattr. changed callback\n\n\n\n\ntranslateY/Z\n\n\n\n\n\n\ntransform:f2\ntransform:f3\n\n\n\n\n\n\n\n\n\n\ncallback\n\n\n\n\nCallback node\n\n\n\n\ntransform node msg. attr.\n\n\n\n\ninstallation callback\n\n\n\n\ncallback registry\n\n\n\n\n\n\ntransform:f1\ncallback:f1\n\n\n\n\n\n\nmessage conn.\n\n\n\n\n\n\ntransform:f3\ncallback:f3\n\n\n\n\n\n\ndone!\n\n\n\n\n\n\nreadTranslateXCB\n\n\n\n\nCallback function\n\n\n\n\n\n\ntransform:f3\nreadTranslateXCB\n\n\n\n\n\n\n2. Calls function when translateX. \n\n\nchanges interactively on transform node\n\n\n\n\n\n\ncallback:f2\ntransform:f3\n\n\n\n\n\n\n1. Done!\n\n\n\n\n\n\nreadTranslateXCB\ntransform:f4:s\n\n\n\n\n\n\n3. Sets final ty/tz values \n\n\non the transform node\n\n\n\n\n\n\n\n\n\nFast, wasn't it?\n\n\nNow that we're reading the values, we can focus on step 3: setting new values\nback onto the transform node.\n\n\nGetting our spiral behavior working\n\n\nIf you have any background in high school maths at all, you probably know what\ncomes next:\n\n\nvoid featureCallback(MNodeMessage::AttributeMessage msg,\n                     MPlug \nplug,\n                     MPlug \notherPlug,\n                     void *data)\n{\n    if (msg != (MNodeMessage::kAttributeSet|MNodeMessage::kIncomingDirection)) {\n        return;\n    }\n    const char *plugName = plug.partialName(0,0,0,0,0,1).asChar();\n    if (strstr(\ntranslateX\n, plugName) == NULL) {\n        return;\n    }\n    MStatus status;\n    MPlug transformPlug = plug.parent(\nstatus);\n    if (status != MStatus::kSuccess) {\n        return;\n    }\n    double xVal = plug.asDouble();\n    MPlug transformYPlug = transformPlug.child(1, \nstatus);\n    if (status != MStatus::kSuccess) {\n        return;\n    }\n    MPlug transformZPlug = transformPlug.child(2, \nstatus);\n    if (status != MStatus::kSuccess) {\n        return;\n    }\n    double newYVal = sin(xVal);\n    double newZVal = cos(transformZPlug.asDouble() + xVal);\n    transformYPlug.setDouble(newYVal);\n    transformZPlug.setDouble(newZVal);\n}\n\n\n\n\nThat's right, simple trigonometry functions!\n\n\nAnd just like that, we're done!\n\n\n...Kind of. There's just a bit of cleanup to do: in the \nuninitializePlugin\n\nfunction we wrote earlier, we need to make sure that we call\n\nuninstallCallback()\n as well to remove all the callbacks from the global\nregistry (since we don't want those to persist if we remove the callback node\nfrom the scene).\n\n\n\nMStatus uninitializePlugin(MObject obj)\n{\n    MFnPlugin plugin(obj);\n    MStatus status;\n    uninstallCallback();\n    status =  plugin.deregisterNode(CallbackNode::kNODE_ID);\n    CHECK_MSTATUS_AND_RETURN_IT(status);\n\n    status = plugin.deregisterCommand(ApplyCallbackCommand::kCOMMAND_NAME);\n    CHECK_MSTATUS_AND_RETURN_IT(status);\n\n    return status;\n}\n\n\n\n\n\nOk, \nnow\n we're done.\n\n\nConclusion\n\n\nIs this the right solution for everything? No, absolutely not. This method is\nbest used for installable features onto a rig where you can control the entire\nbehaviour of the feature within a single set of depedency nodes that you\ncontrol. You also need to take care that you do not trigger unnecessary DG\nevaluations within your callback methods that could potentially cause cycles in\nthe DG (which won't be caught by Maya!)\n\n\nHowever, this method will work far better than using \nscriptNodes\n, since they\nwill work even when referenced, thus making them far better suited to\nproduction. You also are able to reason about the current callbacks that have\nbeen registered far more easily than if you had been using script nodes and\nmanaging which ones were registered to which namespace/object combinations in\nthe scene.\n\n\nUse with a healthy dose of caution and wonder, as always!", 
            "title": "Home"
        }, 
        {
            "location": "/#tutorial", 
            "text": "", 
            "title": "Tutorial"
        }, 
        {
            "location": "/#about", 
            "text": "This is a tutorial on how to write a node that sets up features in your Maya\nscene without having explicit dirty propagation relationships in the dependency graph.  For this node, we're going to focus mostly on the  how  of writing the node\nitself, and thus the actual functionality will be restricted to something very\nbasic; in this case, creating a spiral motion when a user moves the transform\nnode in the scene that we set up the feature for.  For more information on this approach to setting up scene features, please refer\nto  Raffaele Fragapane's   Cult Of Rig  series on the\nreasoning behind this approach.", 
            "title": "About"
        }, 
        {
            "location": "/#why-not-just-do-what-raffaele-does-and-use-a-scriptnode", 
            "text": "The reason we're using a compiled node here instead of a  scriptNode  as he\ndetails in the original approach is due to the fact that the script executed\nfrom a script node in Maya has no concept of which node executed it, and thus\nmakes it very difficult to implement in production when you reference this\nscript node in a separate namespace without implementing a callback manager of\nsome sort to manage the callbacks you are installing into the scene, along with\nmanaging the associated namespaces/nodes for each of those callbacks registered\nby the script node.  By using a compiled node instead, we can manage all of that registration/\nun-registration mess within the node itself much more cleanly and reason about\nthe state of our Maya scene a lot more easily than a script node would otherwise\nhave allowed for.", 
            "title": "Why not just do what Raffaele does and use a scriptNode?"
        }, 
        {
            "location": "/#requirements", 
            "text": "", 
            "title": "Requirements"
        }, 
        {
            "location": "/#what-you-should-know", 
            "text": "Basic knowledge of C/C++ . I will focus on including only the code that is\n  important; I expect you to be able to understand how to fill in the rest as needed.  Knowledge of how the dependency graph works in Maya and how dirty propagation works.  Basic knowledge of how Maya plugins work and how to write/build them . There is\n  a sample  CMakeLists.txt  build script provided for reference if you need a\n  refresher on that.  If you're unfamilar with Maya's callback mechanisms, to  watch the stream \n  listed above to get an idea of what's going on and how they tie to dirty\n  propagation in the dependency graph.  Most importantly:  How to convert between tabs/spaces.  (Of course, you\n  should also prefer tabs, but this is a well-understood  fact , and so I don't\n  think further discussion is required on the topic.)", 
            "title": "What you should know"
        }, 
        {
            "location": "/#getting-started", 
            "text": "Firstly, we'll just get a basic skeleton setup of the plugin going. As a refresher,\nthis just means that you need to create a defintion of a  MPxNode \nthat implements a creator function and an initializer function, which\nwe will call  creator()  and  initialize()  respectively.  Thus, in  callback_node.h :  /// This is a dependency node that will install a callback during its lifetime.\nclass CallbackNode : MPxNode\n{\npublic:\n    static void *creator();\n\n    static MStatus initialize();\n\n    static const MTypeId kNODE_ID;      /// The unique ID that identifies this node.\n    static const MString kNODE_NAME;    /// The name of the DG node.  And  callback_node.cpp , which, for now, looks pretty sparse:  #include  callback_node.h \n\nconst MTypeId CallbackNode::kNODE_ID(0x0007ffff);\nconst MString CallbackNode::kNODE_NAME =  callbackNodeExample ;\n\n\nvoid *CallbackNode::creator()\n{\n    return new CallbackNode();\n}\n\n\nMStatus CallbackNode::initialize()\n{\n    MStatus result;\n    return result;\n}  We also add two extra attributes called  kNODE_ID  and  kNODE_NAME  to help\nus identify the dependency node later on.  Great! We've got our node now, let's write the basic plugin structure to\nregister it. In case you needed a refresher:  In  plugin_main.cpp :  #include  plugin_main.h \n#include  maya/MFnPlugin.h \n\nconst char *kAUTHOR =  Me, the author ;\nconst char *kVERSION =  1.0.0 ;\nconst char *kREQUIRED_API_VERSION =  Any ;\n\n\nMStatus initializePlugin(MObject obj)\n{\n    MStatus status;\n    MFnPlugin plugin(obj, kAUTHOR, kVERSION, kREQUIRED_API_VERSION);\n\n    status = plugin.registerNode(CallbackNode::kNODE_NAME,\n                                 CallbackNode::kNODE_ID,\n                                  CallbackNode::creator,\n                                  CallbackNode::initialize,\n                                 MPxNode::kDependNode);\n    CHECK_MSTATUS_AND_RETURN_IT(status);\n\n    return status;\n}\n\n\nMStatus uninitializePlugin(MObject obj)\n{\n    MFnPlugin plugin(obj);\n\n    MStatus status;\n    status =  plugin.deregisterNode(CallbackNode::kNODE_ID);\n    CHECK_MSTATUS_AND_RETURN_IT(status);\n\n    return status;\n}  In  plugin_main.h , I go ahead and setup a  Single Translation Unit (STU)\nBuild/Unity build  (which is easy, since there's only one\nsource file right now):   #include  callback_node.cpp \n\nMStatus initializePlugin(MObject obj);\n\nMStatus uninitializePlugin(MObject obj);  You should be able to call the compiler command on your corresponding platform\non just  plugin_main.cpp  and have the plugin compile correctly.  I will not go into the details regarding a STU build here, but suffice to say\nthat I have found them much more beneficial to build times than any other\ncompiler feature (LTO, IncrediBuild, splitting the code out into pre-compiled\nlibs, whatever). For such a small project, it doesn't matter; you can switch back\nto a more traditional build setup if you prefer.  If you have issues building the plugin on your own, please refer to the\nincluded  CMakeLists.txt  to see how I manage my own builds. You are not\nrequired to use CMake; it is just my own preference.  If you got past all that and got a plugin building, great! We have a node that\ndoes...well,  nothing .  Now we just need to make it work.", 
            "title": "Getting started"
        }, 
        {
            "location": "/#what-are-we-even-doing", 
            "text": "So before we jump into the node's features itself, let's take a step back and\nthink about what we want this node to do at a high-level:        callbackNodeExample    transform   Transform node    callback   Callback node    transform callback      1. Read translateX    callback transform      2. Set new translate Y/Z in a spiral ly fashion     Ok. So we know that we want to our node read the translate information from the \ntransform node. However, I just promised that we wouldn't have explicit\nconnections between our nodes in the DG. So what we'll do instead is use message attributes  to do the job of making sure our nodes know about each\nother. Kind of like Tinder, but just for DG nodes.", 
            "title": "What are we even doing?"
        }, 
        {
            "location": "/#creating-the-message-attribute", 
            "text": "If you need a refresher on what a message attribute is:   A message attribute is a dependency node attribute that does not transmit\ndata .  Message attributes only exist to formally declare relationships between\nnodes. By connecting two nodes via message attributes, a relationship between\nthose nodes is expressed.  The Maya Documentation for  MFnMessageAttribute , verse 2:0   Basically, by utilizing this Maya feature, we'll be able to avoid having any data\ntransmitted explicitly in the graph; we'll be reading it directly from the\ntransform node itself.  Let's add this message attribute to our custom node definition:  const char *CallbackNode::kIN_TRANSFORM_ATTR_NAME =  transform ;\nMObject CallbackNode::inTransformAttr;\n\n\nMStatus CallbackNode::initialize()\n{\n    MStatus result;\n\n    MFnMessageAttribute fnMsgAttr;\n    inTransformAttr = fnMsgAttr.create(CallbackNode::kIN_TRANSFORM_ATTR_NAME,\n                                       CallbackNode::kIN_TRANSFORM_ATTR_NAME,\n                                        result);\n    CHECK_MSTATUS_AND_RETURN_IT(result);\n\n    addAttribute(inTransformAttr);\n    return result;\n}  However, let's not forget that this attribute needs to be connected to\nsomething. In this case, that something is the transform node that we're going\nto be moving around.", 
            "title": "Creating the message attribute"
        }, 
        {
            "location": "/#writing-the-mpxcommand-to-setup-everything", 
            "text": "To make things easier for our end-users, let's make a  MPxCommand  that they \ncan run in order to create our node automatically, along with handling the connections \nbetween it and the transform node. If you've never written such a thing before\nor need some reference, the command I've written is below:  apply_callback_command.h  class ApplyCallbackCommand : public MPxCommand\n{\npublic:\n    static void *creator();\n\n    MStatus doIt(const MArgList  args);\n\n    MStatus redoIt();\n\n    MStatus undoIt();\n\n    bool isUndoable() const;\n\n    static MSyntax newSyntax();\n\n    /// The name of the command that is meant to be run.\n    static const MString kCOMMAND_NAME;\n\n    MStatus parseArgs(const MArgList  args);\n\n    /// Storage for the flag arguments that will be passed into the command.\n    bool flagHelpSpecified = false;\n    MSelectionList flagSelList;\n\n    /// Storage for the operations that this command performs on the DG so that we\n    /// can undo them if necessary.\n    MDGModifier dgMod;\n};  And  apply_callback_command.cpp :  \nconst char *flagSelListLongName =  -node ;\nconst char *flagSelListShortName =  -n ;\n\nconst char *flagHelpLongName =  -help ;\nconst char *flagHelpShortName =  -h ;\n\nconst char *helpText =  This command will setup a callback on a given node.\\n \n     Usage:\\n   applyCallback [options]\\n \n     Options:\\n \n     -h / -help     Prints this message.\\n\\n \n     -n / -node     The name of the node to setup the callback example for.\\n\\n ;\n\nconst MString ApplyCallbackCommand::kCOMMAND_NAME =  applyCallback ;\n\n\nvoid *ApplyCallbackCommand::creator()\n{\n    return new ApplyCallbackCommand();\n}\n\n\nMSyntax ApplyCallbackCommand::newSyntax()\n{\n    MSyntax syntax;\n    syntax.addFlag(flagHelpShortName, flagHelpLongName);\n    syntax.addFlag(flagSelListShortName, flagSelListLongName, MSyntax::kSelectionItem);\n    syntax.enableQuery(false);\n    syntax.enableEdit(false);\n    syntax.useSelectionAsDefault(true);\n\n    return syntax;\n}\n\n\nMStatus ApplyCallbackCommand::parseArgs(const MArgList  args)\n{\n    MStatus result;\n    MArgDatabase argDb(syntax(), args,  result);\n    CHECK_MSTATUS_AND_RETURN_IT(result);\n\n    if (argDb.isFlagSet(flagHelpShortName)) {\n        displayInfo(helpText);\n        flagHelpSpecified = true;\n        return MStatus::kSuccess;\n    } else {\n        flagHelpSpecified = false;\n    }\n\n    if (argDb.isFlagSet(flagSelListShortName)) {\n        argDb.getFlagArgument(flagSelListShortName, 0, flagSelList);\n    }\n\n    return result;\n}\n\n\nMStatus ApplyCallbackCommand::doIt(const MArgList  args)\n{\n    setCommandString(ApplyCallbackCommand::kCOMMAND_NAME);\n    clearResult();\n\n    MStatus result = parseArgs(args);\n    CHECK_MSTATUS_AND_RETURN_IT(result);\n\n    if (this- flagHelpSpecified == true) {\n        return MStatus::kSuccess;\n    }\n\n    return redoIt();\n}\n\n\nMStatus ApplyCallbackCommand::redoIt()\n{\n    MStatus result;\n    if (flagSelList.length() != 1) {\n        MGlobal::displayError( You need to select a single node to apply the callback to! );\n        return MStatus::kInvalidParameter;\n    }\n\n    if (doesCallbackNodeAlreadyExist() == true) {\n        MGlobal::displayError( The feature already exists! );\n        return MStatus::kFailure;\n    }\n\n    MObject callbackNode = dgMod.createNode(CallbackNode::kNODE_ID,  result);\n    CHECK_MSTATUS_AND_RETURN_IT(result);\n    result = dgMod.doIt();\n    CHECK_MSTATUS_AND_RETURN_IT(result);\n\n    MFnDependencyNode fnNode(callbackNode);\n    MPlug callbackNodeMsgPlug = fnNode.findPlug(CallbackNode::kIN_TRANSFORM_ATTR_NAME,\n                                                false,\n                                                 result);\n    CHECK_MSTATUS_AND_RETURN_IT(result);\n\n    MObject transform;\n    result = flagSelList.getDependNode(0, transform);\n    CHECK_MSTATUS_AND_RETURN_IT(result);\n    if (!transform.hasFn(MFn::kDependencyNode)) {\n        MGlobal::displayError( The object specified is not a valid DG node! );\n        return MStatus::kInvalidParameter;\n    }\n\n    return result;\n}\n\n\nMStatus ApplyCallbackCommand::undoIt()\n{\n    dgMod.undoIt();\n    return MStatus::kSuccess;\n}\n\n\nbool ApplyCallbackCommand::isUndoable() const\n{\n    if (flagHelpSpecified == true) {\n        return false;\n    } else {\n        return true;\n    }\n}  It's a bit of boilerplate code to write, but it's not that complicated when you\nsee what it's actually doing. We basically create a new  CallbackNode , \naccept a single transform as a command argument, and do some basic sanity\nchecking of the inputs to make sure everything's good. Nothing special, really.   (Again, if something here doesn't make sense to you, please look through some of\nthe examples of how to write command plugins in the Maya documentation.)  There's one thing we need to do before we call this command good, though; we\nneed to actually make the connection between the callback node and the transform\nnode that we pass to the command:      //... the earlier part of redoIt()\n    MObject transform;\n    result = flagSelList.getDependNode(0, transform);\n    CHECK_MSTATUS_AND_RETURN_IT(result);\n    if (!transform.hasFn(MFn::kDependencyNode)) {\n        MGlobal::displayError( The object specified is not a valid DG node! );\n        return MStatus::kInvalidParameter;\n    }\n    result = fnNode.setObject(transform);\n    CHECK_MSTATUS_AND_RETURN_IT(result);\n    if (!fnNode.hasAttribute(CallbackNode::kMSG_CXN_ATTR_NAME)) {\n        MFnMessageAttribute fnMsgAttr;\n        MObject msgAttr = fnMsgAttr.create(CallbackNode::kMSG_CXN_ATTR_NAME,\n                                           CallbackNode::kMSG_CXN_ATTR_NAME,\n                                            result);\n        CHECK_MSTATUS_AND_RETURN_IT(result);\n        fnNode.addAttribute(msgAttr);\n    }\n    MDGModifier dgModCxn;\n    MPlug msgPlug = fnNode.findPlug(CallbackNode::kMSG_CXN_ATTR_NAME, false,  result);\n    CHECK_MSTATUS_AND_RETURN_IT(result);\n    result = dgModCxn.connect(msgPlug, callbackNodeMsgPlug);\n    CHECK_MSTATUS_AND_RETURN_IT(result);\n    dgModCxn.doIt();  We basically create a new message attribute on the transform node and connect it\nup (using a different  MDGModifier , since our internal one is going to be\nreserved for deleting the callback node we created if the user chooses to undo,\nand deleting the node will automatically break the connections anyway)  We also need to define  CallbackNode::kMSG_CXN_ATTR_NAME  and  CallbackNode::kIN_TRANSFORM_ATTR_NAME , which will be the names of the\nmessage attributes on the callback and transform nodes respectively. You can do\nthat in the respective source files however you like.", 
            "title": "Writing the MPxCommand to setup everything"
        }, 
        {
            "location": "/#getting-somewhere", 
            "text": "Once all of that is done and your plugin is built, you should be able to run the \nfollowing MEL script (or similar):  file -f -newFile;\nunloadPlugin  callbackNodeExample ;\nloadPlugin  c:/Users/sonictk/Git/experiments/maya_node_callback_example/build/Debug/callbackNodeExample.mll ;\n\ncreateNode  transform ;\napplyCallback -n  transform1 ;  Which should give you something similar to the following:        callbackNodeExample    transform   Transform node   callback node msg. attr.    callback   Callback node   transform node msg. attr.    transform:f1 callback:f1    message conn.     If you're still following along; great! Let's now focus on actually  doing \nsomething useful with the nodes we've made.", 
            "title": "Getting somewhere"
        }, 
        {
            "location": "/#a-more-detailed-overview-of-the-entire-setup", 
            "text": "Now that we've established the relationship between the nodes, let's think about\nwhat we need to do next. We know that we want to get the  translateX  value\nfrom the transform node whenever a user changes it interactively. We also know\nthat we don't want this behaviour to be dirty propagation-based (i.e. no\nexplicit connection in the graph).   If you paid attention at all during the stream, you'll know what the answer is:\nit's in the form of Maya's various callback mechanisms. However, before we jump\nright into writing it up, let's think a little again over what we need to do in\ngreater detail this time:        callbackNodeExample    transform   Transform node   callback node msg. attr.   translateX   attr. changed callback   translateY/Z    transform:f2 transform:f3      callback   Callback node   transform node msg. attr.   installation callback   callback registry    transform:f1 callback:f1    message conn.    transform:f3 callback:f3    callback ID is stored so that   it can be un registered on node   deletion/disconnection    readTranslateXCB   Callback function    transform:f3 readTranslateXCB    2. Calls function when translateX.   changes interactively on transform node    callback:f2 transform:f3    1. Registers this callback when   node is created/connected    readTranslateXCB transform:f4:s    3. Sets final ty/tz values   on the transform node     Ok, that's a little confusing. As\na  great man  \nonce said, let's  break it down .", 
            "title": "A more detailed overview of the entire setup"
        }, 
        {
            "location": "/#registering-the-callback-onto-the-transform-node", 
            "text": "callbackNodeExample    transform   Transform node   callback node msg. attr.   translateX   attr. changed callback   translateY/Z    transform:f2 transform:f3      callback   Callback node   transform node msg. attr.   installation callback   callback registry    transform:f1 callback:f1    message conn.    transform:f3 callback:f3    callback ID is stored so that   it can be un registered on node   deletion/disconnection    readTranslateXCB   Callback function    transform:f3 readTranslateXCB    2. Calls function when    translateX.   changes interactively on transform node    callback:f2 transform:f3    1. Registers this callback when   node is created/connected    readTranslateXCB transform:f4:s    3. Sets final ty/tz values   on the transform node     We already did the message connection earlier, so we can move on.        callbackNodeExample    transform   Transform node   callback node msg. attr.   translateX   attr. changed callback   translateY/Z    transform:f2 transform:f3      callback   Callback node   transform node msg. attr.   installation callback   callback registry    transform:f1 callback:f1    message conn.    transform:f3 callback:f3    callback ID is stored so that   it can be un registered on node   deletion/disconnection    readTranslateXCB   Callback function    transform:f3 readTranslateXCB    2. Calls function when    translateX.   changes interactively on transform node    callback:f2 transform:f3    1. Registers this callback when   node is created/connected    readTranslateXCB transform:f4:s    3. Sets final ty/tz values   on the transform node     Let's start here instead. We need to set-up a callback on the callback node when\nit is created that is responsible for  setting up another callback on the\ntransform node  in order to watch for any attribute changes on it. We can do\nthis by making use of the  MPxNode::postConstructor  virtual method, like so:  \nvoid CallbackNode::postConstructor()\n{\n    MStatus status;\n    MObject thisNode = thisMObject();\n\n    MCallbackId installId = MNodeMessage::addAttributeChangedCallback(thisNode,\n                                                                      installCallback,\n                                                                      NULL,\n                                                                       status);\n    if (status != MStatus::kSuccess) {\n        MGlobal::displayError( Unable to install example feature! );\n        uninstallCallback();\n        return;\n    }\n    callbacks.append(installId);\n    MNodeMessage::addNodePreRemovalCallback(thisNode,\n                                            uninstallCallback,\n                                            NULL,\n                                             status);\n    if (status != MStatus::kSuccess) {\n        MGlobal::displayError( Unable to install example feature! );\n        uninstallCallback();\n        return;\n    }\n}  What are  installCallback  and  uninstallCallback , you ask? Let's take a\nlook at the documentation for both  MNodeMessage::addAttributeChangedCallback \nand  MNodeMessage::addNodePreRemovalCallback  to get some hints:  MCallbackId addAttributeChangedCallback(MObject  node, \n                                        MNodeMessage::MAttr2PlugFunction func, \n                                        void *clientData = NULL, \n                                        MStatus *ReturnStatus = NULL)\n\nMCallbackId addNodePreRemovalCallback(MObject  node, \n                                      MMessage::MNodeFunction func, \n                                      void *clientData = NULL, \n                                      MStatus *ReturnStatus = NULL)  So basically our  installCallback  and  uninstallCallback  functions need to\nmatch the signatures of a  MAttr2PlugFunction  and a  MNodeFunction ,\nwhatever those might be. Looking at an  MAttr2PlugFunction  signature gives\nthe following:  \ntypedef void(* MAttr2PlugFunction) (MNodeMessage::AttributeMessage msg, \n                                    MPlug  plug, \n                                    MPlug  otherPlug, \n                                    void *clientData)  Basically a function pointer that takes two  MPlugs . And a  MNodeFunction ?  \ntypedef void(* MNodeFunction) (MObject  node, void *clientData)  Yep, a function pointer that takes a  MObject  node. Not terribly complicated,\nwhich is always good.  Knowing this, we can go ahead and starting writing our callback functions:  \nMStatus uninstallCallback()\n{\n    MStatus status = MMessage::removeCallbacks(CallbackNode::callbacks);\n    MGlobal::displayInfo( Removed feature! );\n    return status;\n}\n\n\nvoid uninstallCallback(MObject  node, void *data)\n{\n    uninstallCallback();\n}\n\n\nvoid installCallback(MNodeMessage::AttributeMessage msg,\n                     MPlug  plug,\n                     MPlug  otherPlug,\n                     void *data)\n{\n    if (msg == (MNodeMessage::kConnectionBroken|\n                MNodeMessage::kIncomingDirection|\n                MNodeMessage::kOtherPlugSet)) {\n        uninstallCallback();\n    }\n    if (msg != (MNodeMessage::kConnectionMade|\n                MNodeMessage::kIncomingDirection|\n                MNodeMessage::kOtherPlugSet)) {\n        return;\n    }\n    // NOTE: (sonictk) We check if the node has its message connection connected\n    // first to determine if we should install the real callback onto that node\n    MObject callbackNode = plug.node();\n    MFnDependencyNode fnNode(callbackNode);\n    MPlug cxnPlug = fnNode.findPlug(CallbackNode::kIN_TRANSFORM_ATTR_NAME);\n    MPlugArray connectedPlugs;\n    cxnPlug.connectedTo(connectedPlugs, true, false);\n    if (connectedPlugs.length() != 1) {\n        return;\n    }\n    MObject transformNode = connectedPlugs[0].node();\n    if (!transformNode.hasFn(MFn::kTransform)) {\n        return;\n    }\n    // NOTE: (sonictk) Install the callback onto the other node and add it to the\n    // registry of callbacks to track\n    MStatus status;\n    MCallbackId featureCallbackId = MNodeMessage::addAttributeChangedCallback(transformNode,\n                                                                              featureCallback,\n                                                                              NULL,\n                                                                               status);\n    if (status != MStatus::kSuccess) {\n        return;\n    }\n    CallbackNode::callbacks.append(featureCallbackId);\n    MGlobal::displayInfo( Feature installed! );\n\n}  Basically, we check the message type that Maya passes us to see if we care about\nthe type of event that just occurred, and either remove the callbacks from a\nglobal registry that the node maintains if we detect a disconnection, or install\na new callback onto the transform node otherwise. Yes, this means we also need\nto define what this \"global callback registry\" is:  static MCallbackIdArray callbacks;  That's it. No need to over-complicate matters. (Remember, in a STU build, any\nvariable with  static  storage duration is effectively global!)  We'll implement  featureCallback  in a little bit. For now, let's look at what\nour overview looks like now:        callbackNodeExample    transform   Transform node   callback node msg. attr.   translateX   attr. changed callback   translateY/Z    transform:f2 transform:f3      callback   Callback node   transform node msg. attr.   installation callback   callback registry    transform:f1 callback:f1    message conn.    transform:f3 callback:f3    callback ID is stored so that   it can be un registered on node   deletion/disconnection    readTranslateXCB   Callback function    transform:f3 readTranslateXCB    2. Calls function when    translateX.   changes interactively on transform node    callback:f2 transform:f3    1. Done!    readTranslateXCB transform:f4:s    3. Sets final ty/tz values   on the transform node     Yes, we did skip a little ahead, but it was all for a good cause. Let's go ahead\nand implement that  featureCallback  now to read the  translateX  value off\nof the transform node.  \nvoid featureCallback(MNodeMessage::AttributeMessage msg,\n                     MPlug  plug,\n                     MPlug  otherPlug,\n                     void *data)\n{\n    if (msg != (MNodeMessage::kAttributeSet|MNodeMessage::kIncomingDirection)) {\n        return;\n    }\n    const char *plugName = plug.partialName(0,0,0,0,0,1).asChar();\n    if (strstr( translateX , plugName) == NULL) {\n        return;\n    }\n    double xVal = plug.asDouble();\n}  As we can see, it's very similar in theory to how we implemented installCallback ; the difference here being that we look for a different type\nof event ( kAttributeSet  instead), and we just get the value of the\ntranslateX plug without doing anything else.  So just like that, our overview looks like this:        callbackNodeExample    transform   Transform node   callback node msg. attr.   translateX   attr. changed callback   translateY/Z    transform:f2 transform:f3      callback   Callback node   transform node msg. attr.   installation callback   callback registry    transform:f1 callback:f1    message conn.    transform:f3 callback:f3    done!    readTranslateXCB   Callback function    transform:f3 readTranslateXCB    2. Calls function when translateX.   changes interactively on transform node    callback:f2 transform:f3    1. Done!    readTranslateXCB transform:f4:s    3. Sets final ty/tz values   on the transform node     Fast, wasn't it?  Now that we're reading the values, we can focus on step 3: setting new values\nback onto the transform node.", 
            "title": "Registering the callback onto the transform node"
        }, 
        {
            "location": "/#getting-our-spiral-behavior-working", 
            "text": "If you have any background in high school maths at all, you probably know what\ncomes next:  void featureCallback(MNodeMessage::AttributeMessage msg,\n                     MPlug  plug,\n                     MPlug  otherPlug,\n                     void *data)\n{\n    if (msg != (MNodeMessage::kAttributeSet|MNodeMessage::kIncomingDirection)) {\n        return;\n    }\n    const char *plugName = plug.partialName(0,0,0,0,0,1).asChar();\n    if (strstr( translateX , plugName) == NULL) {\n        return;\n    }\n    MStatus status;\n    MPlug transformPlug = plug.parent( status);\n    if (status != MStatus::kSuccess) {\n        return;\n    }\n    double xVal = plug.asDouble();\n    MPlug transformYPlug = transformPlug.child(1,  status);\n    if (status != MStatus::kSuccess) {\n        return;\n    }\n    MPlug transformZPlug = transformPlug.child(2,  status);\n    if (status != MStatus::kSuccess) {\n        return;\n    }\n    double newYVal = sin(xVal);\n    double newZVal = cos(transformZPlug.asDouble() + xVal);\n    transformYPlug.setDouble(newYVal);\n    transformZPlug.setDouble(newZVal);\n}  That's right, simple trigonometry functions!  And just like that, we're done!  ...Kind of. There's just a bit of cleanup to do: in the  uninitializePlugin \nfunction we wrote earlier, we need to make sure that we call uninstallCallback()  as well to remove all the callbacks from the global\nregistry (since we don't want those to persist if we remove the callback node\nfrom the scene).  \nMStatus uninitializePlugin(MObject obj)\n{\n    MFnPlugin plugin(obj);\n    MStatus status;\n    uninstallCallback();\n    status =  plugin.deregisterNode(CallbackNode::kNODE_ID);\n    CHECK_MSTATUS_AND_RETURN_IT(status);\n\n    status = plugin.deregisterCommand(ApplyCallbackCommand::kCOMMAND_NAME);\n    CHECK_MSTATUS_AND_RETURN_IT(status);\n\n    return status;\n}  Ok,  now  we're done.", 
            "title": "Getting our spiral behavior working"
        }, 
        {
            "location": "/#conclusion", 
            "text": "Is this the right solution for everything? No, absolutely not. This method is\nbest used for installable features onto a rig where you can control the entire\nbehaviour of the feature within a single set of depedency nodes that you\ncontrol. You also need to take care that you do not trigger unnecessary DG\nevaluations within your callback methods that could potentially cause cycles in\nthe DG (which won't be caught by Maya!)  However, this method will work far better than using  scriptNodes , since they\nwill work even when referenced, thus making them far better suited to\nproduction. You also are able to reason about the current callbacks that have\nbeen registered far more easily than if you had been using script nodes and\nmanaging which ones were registered to which namespace/object combinations in\nthe scene.  Use with a healthy dose of caution and wonder, as always!", 
            "title": "Conclusion"
        }
    ]
}